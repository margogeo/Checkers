"use strict";function HttpLoadGet(Address) { let xmlhttp = new XMLHttpRequest();  xmlhttp.open("GET", Address, false); xmlhttp.send(null);return xmlhttp.responseText;  }let dsk = [    [0, 2, 0, 2, 0, 2, 0, 2],    [2, 0, 2, 0, 2, 0, 2, 0],    [0, 2, 0, 2, 0, 2, 0, 2],    [0, 0, 0, 0, 0, 0, 0, 0],    [0, 0, 0, 0, 0, 0, 0, 0],    [1, 0, 1, 0, 1, 0, 1, 0],    [0, 1, 0, 1, 0, 1, 0, 1],    [1, 0, 1, 0, 1, 0, 1, 0]];let dskStart = dsk;let cBot="ABCDEFGH";let cellToEat="";let x, y, id = 0, st = "", turn = 1;for (y = 0 ; y < 8 ; y++) {    st = st + "<tr>";    for (x = 0; x < 8; x++) {        if( ((x + y) & 1) == 0)            st = st + "<th width=100 height=100 class = 'wcl pass'  id = '" + id + "'></th>";        else {            st = st + "<th width=100 height=100 class = 'bcl pass' id = '" + id + "' onClick = 'move(" + id + ")'>";            if(dsk[y][x] == 2)                st = st + "<img src = 'black.png'>";            if(dsk[y][x] == 1)                st = st + "<img src = 'white.png'>";            st = st + "</th>";        }        id = id + 1;    }    st = st + "</tr>\n";}let vdsk = document.getElementById("dsk");vdsk.innerHTML = st;let xfrom = -1, yfrom = -1, clr = 0, check = -1, last = true;//check is used to differ regular moves from taking ones                                                     //last shows if player has taken every possible checkerfunction DrawDesk(){	let cimg = ["", "white.png", "black.png", "white_queen.png", "black_queen.png"];    let y, x;	let num = [0, 0, 0, 0, 0, 0]; // number of white and black checkers    for (y = 0; y < 8 ; y++) {        for (x = 0; x < 8; x++) {            let cid = y * 8 + x;            let scl = "";			num[dsk[y][x]]++;            if (dsk[y][x] > 0)                scl = "<img src='" + cimg[dsk[y][x]] + "'>";            document.getElementById(cid).innerHTML = scl;        }    }	if (num[1] + num[3] == 0) {		alert("computer won!");		Login("D");         dsk = dskStart, id = 0, st = "", turn = 1; 		return;	}	if (num[2] + num[4] == 0) {		alert("you won!");		Login("W");        dsk = dskStart, id = 0, st = "", turn = 1;   		return;	}}function wrongMove() {	let mc=cBot[xfrom] + (8-yfrom) + " => " + cBot[x]+(8-y);	alert("wrong move " + mc);}var pSelX = -1, pSelY = -1;function selCell(y,x) {	if(pSelX >= 0 && pSelY >= 0) {		let id = pSelY * 8 + pSelX;		let elem = document.getElementById(id);		elem.classList.remove("activ");		elem.classList.add("pass");		pSelY = -1;	}	let id = y * 8 + x;	if(id >= 0 && id < 64) {		pSelX = x;		pSelY = y;		let elem = document.getElementById(id);		elem.classList.remove("pass");		elem.classList.add("activ");    	}}function move(id){    x = id % 8;	y = (id - x) / 8;	    //picking a checker    if (xfrom < 0 || dsk[y][x] > 0) {        if (dsk[y][x] == 0) {            alert("invalid move");            return;        }        xfrom = x;        yfrom = y;		selCell(y,x);        clr = dsk[y][x];        if (clr > 2)            clr -= 2;        /*if (check == 4 + turn && clr != turn && last) {            turn = 1 + (turn % 2);        }*/    }    //picking a new position for a checker    else {        if (clr == 2 || clr == 4) {            alert("Select white checker");            return;        }        if (dsk[yfrom][xfrom] < 3) { //basic checker's move            if (Math.abs(x - xfrom) == 2 && Math.abs(y - yfrom) == 2 && dsk[y][x] == 0) {                let cx = (x + xfrom) / 2, cy = (y + yfrom) / 2;                //checking if there is an opponent's checker on the way                if (dsk[cy][cx] % 2 == (5 - dsk[yfrom][xfrom]) % 2 && dsk[cy][cx] != 0) {                    dsk[cy][cx] = 0;                    dsk[y][x] = dsk[yfrom][xfrom];                    //a checker -> a King                    if ((dsk[y][x] == 1 && y == 0) || (dsk[y][x] == 2 && y == 7)) {                        dsk[y][x] += 2;                    }                    dsk[yfrom][xfrom] = 0;                    check = 4 + clr;                    DrawDesk();                    xfrom = -1;					selCell(-1,-1);					getMove(y,x);                    return;                }            }            //forbid moving on more than one cell            if (clr == 1 && y != yfrom - 1 ||                clr == 2 && y != yfrom + 1 ||                x != xfrom - 1 && x != xfrom + 1 ||                dsk[y][x] != 0) {					wrongMove();					return;            }        } else { //King's move            if (Math.abs(x - xfrom) == Math.abs(y - yfrom) && dsk[y][x] == 0) {                let s = Math.sign(y - yfrom);                let ss = Math.sign(x - xfrom);                for (let i = 2; i < Math.abs(x - xfrom); i++) {                    if (dsk[Math.abs(y - s * i)][Math.abs(x - ss * i)] != 0) {						wrongMove();                        return;                    }                }                //forbid jumping over a same color checker                if (dsk[Math.abs(y - s)][Math.abs(x - ss)] % 2 == clr % 2 && dsk[Math.abs(y - s)][Math.abs(x - ss)] != 0                    && Math.abs(y - yfrom) > 1) {                    wrongMove();                    return;                }                //taking an opponent's checker                if (dsk[Math.abs(y - s * 1)][Math.abs(x - ss * 1)] != 0 && Math.abs(y - yfrom) > 1) {                    dsk[Math.abs(y - s * 1)][Math.abs(x - ss * 1)] = 0;                    check = 4 + clr;                    for (let k = 1; k < 64; k++) {                        let xx = k % 8, yy = (k - xx) / 8;                        if (dsk[yy][xx] == clr + 2) {                            last = kingCells(yy, xx, clr);                            if (!last)                                break;                        }                    }                } else { //for a regular move                    for (let k = 1; k < 64; k++) {                        let xx = k % 8, yy = (k - xx) / 8;                        if (dsk[yy][xx] == clr + 2) {                            if (!kingCells(yy, xx, clr)) {                                alert("take an opponent's checker first " + cellToEat);                                return;                            }                        }                    }                    if (check == 4 + turn && clr == turn) {                        //turn = 1 + (turn % 2);                        alert("Select white checker!");                        return;                    }                    //turn = 1 + (turn % 2);                    check = 0;                }                dsk[y][x] = dsk[yfrom][xfrom];                dsk[yfrom][xfrom] = 0;                DrawDesk();                xfrom = -1;				selCell(-1, -1);				getMove(y, x);                return;            } else {                wrongMove();                return;            }        }        //actions for a move without taking opponent's checkers        for (let k = 1; k < 64; k++) {            let xx = k % 8, yy = (k - xx) / 8;            if(dsk[yy][xx] == clr ) {                if (!cells(yy, xx, clr)) {                    alert("take an opponent's checker first " + cellToEat);                    return;                }            }			selCell(-1, -1);        }        if (clr == 2 || clr == 4) {            alert("another player's turn= " + turn + " " + clr);            return;        }        dsk[y][x] = dsk[yfrom][xfrom];        //a checker -> a King        if ((dsk[y][x] == 1 && y == 0) || (dsk[y][x] == 2 && y == 7)) {            dsk[y][x] += 2;        }        dsk[yfrom][xfrom] = 0;        check = 0;        DrawDesk();        xfrom = -1;        yfrom = -1;		getMove(0, 0);    }}//checking if there are opponents' checkers left for takingfunction cells(y, x, clr) {   let dx, dy, tx, ty;    for (dy = -1 ; dy <= 1 ; dy += 2)	 for (dx = -1 ; dx <= 1 ; dx += 2) {		ty = y + 2 * dy;		tx = x + 2 * dx;		if(tx >= 0 && ty >= 0 && ty < 8 && tx < 8 && dsk[ty][tx] == 0){			let clt = dsk[y + dy][x + dx];			if(clt && ((clt ^ clr) & 1)) {				cellToEat = cBot.substring(x, x + 1) + (y + 1) + "=> " +							cBot.substring(x + dx, x + dx + 1) + (y + dy + 1);				return false;			}		}	}	return true;}//same but for Kingsfunction kingCells(i, j, clr) {   let dx, dy, tx, ty, k;    for (dy = -1 ; dy <= 1 ; dy += 2)	 for (dx = -1 ; dx <= 1 ; dx += 2) 		for (k = 1; k < 7 ; k++) {			ty = y + k * dy;			tx = x + k * dx;			if(tx < 1 || ty < 1 || tx > 6 || ty > 6)				break;					let clt = dsk[ty][tx];			if(clt) {				if((clt ^ clr) & 1) {					if(dsk[ty + dy][tx + dx] == 0)						return false;				}				break;			}		}		    return true;}function getMove(ey, ex) {if (ey > 0 || ex > 0) {  let isNextEat = dsk[ey][ex] > 2 ? kingCells(ey, ex, 1) : cells(ey, ex, 1);  if (!isNextEat) {	selCell(ey, ex);	yfrom = ey;	xfrom = ex;	return;  }}	let i, j, deskState="G";for (i = 0; i < 8; i++) for (j = 0; j < 8; j++)  deskState += dsk[i][j];  let ret = HttpLoadGet("GetMove.cgi?" + deskState);  let lr = ret.length;  if(lr < 7 || ret.substr(0, 1) != "+") {	alert("No server response !");	return;  }  let from = parseInt(ret.substring(1, 4));  let to = parseInt(ret.substring(4, 7));    let y1 = parseInt(from / 8), x1 = from % 8;  selCell(y1, x1);  DrawDesk();  setTimeout(() => {    selCell(-1, -1);  let yto = parseInt(to / 8);  if (dsk[y1][x1] == 1 && yto == 0 || dsk[y1][x1] == 2 && yto == 7)	dsk[y1][x1] += 2;  dsk[yto][to%8] = dsk[y1][x1];  dsk[y1][x1] = 0;  for (i = 7; i < lr -2 ; i += 3) {	  let eat = parseInt(ret.substring(i, i + 3));	  dsk[parseInt(eat / 8)][eat % 8] = 0;  }  DrawDesk(); }, 1200);}let psw="", usr="";function showUser(ret) {	if (ret.substr(0,1) != "+") {		alert("No server response !");		return;	}    let win=0, def=0;	if (ret.length > 5) {		win = ret.substring(1,4);		def = ret.substring(4,7);	}	document.getElementById("regis").innerHTML = "<center><font size = '+3' color='green'>You are logged in as<br>"		 + usr + "<br><br>Your score:<br><br>Wins:" + win + "  Defeats:" + def + " </font></center>";}function Login(vr){    if (vr != "W" && vr != 'D') { 		psw = document.getElementById("psw").value;		usr = document.getElementById("usr").value;		if (psw.length < 3 || usr.length < 3) {			alert("User name and password should be 3 symbols at least!");			return;		}	}	let ret = HttpLoadGet("GetMove.cgi?" + vr + "usr=" + usr + "&" + "psw="  + psw);	if (ret.substr(0,1) == "-") {		if (vr == 'L')			alert("User name and/or password is incorrect");		else			alert("User name already exists");		return;	}		showUser(ret);}